{{- block "primaryFromRequest" . }}
	{{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }}, err := handler.primaryFromRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
{{- end }}
{{- block "createHandler" . }}
// Post is the http handler func to allow creating a record
func (handler *{{ renderHandlerName . }}) Post(w http.ResponseWriter, r *http.Request) {
	b, err := io.ReadAll(r.Body)
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()

	var {{ renderCamel .Name }} {{ renderPascal .Name }}
	err = json.Unmarshal(b, &{{ renderCamel .Name }})
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	err = handler.store.Create(&{{ renderCamel .Name }})
	if err != nil {
		{{- if $.HasValidity }}
		if errors.Is(err, ErrValidation) {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		{{- else }}
		// NOTE: lack of validity err check
		{{- end }}
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	b, err = json.Marshal({{ renderCamel .Name }})
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Add("Content-Type", "application/json")
	w.Write(b)
}
{{- end }}
{{- block "readHandler" . }}
{{ $entity := . }}
// Get is the http handler func to allow reading a record
func (handler *{{ renderHandlerName . }}) Get(w http.ResponseWriter, r *http.Request) {
	{{- template "primaryFromRequest" . }}
{{ if gt (len .Relations) 0 }}
	var one any
	switch r.URL.Query().Get("include") {
{{- range $index, $relation := .Relations }}
	case "{{ $relation.HasName }}":
		one, err = handler.store.ReadWith{{ renderPascal $relation.HasName }}({{ range $index, $element := $entity.Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
{{- end }}	
	default:
		one, err = handler.store.Read({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
	}
{{- else }}
	one, err := handler.store.Read({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
{{- end }}
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}	

	b, err := json.Marshal(one)
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Add("Content-Type", "application/json")
	w.Write(b)
}
{{- end }}
{{- block "readManyHandler" . }}
// GetMany is the http handler func to allow reading many records
func (handler *{{ renderHandlerName . }}) GetMany(w http.ResponseWriter, r *http.Request) {
	limitStr := r.FormValue("limit")
	limit, err := strconv.Atoi(limitStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	offsetStr := r.FormValue("offset")
	offset, err := strconv.Atoi(offsetStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	many, err := handler.store.ReadMany(limit, offset, handler.WhereClauseItemFromRequest(r))
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	b, err := json.Marshal(many)
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Add("Content-Type", "application/json")
	w.Write(b)
}
{{- end }}
{{- block "updateHandler" . }}
// Put is the http handler func to allow replacing a record
func (handler *{{ renderHandlerName . }}) Put(w http.ResponseWriter, r *http.Request) {
	{{- template "primaryFromRequest" . }}
	b, err := io.ReadAll(r.Body)
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()

	var {{ renderCamel .Name }} {{ renderPascal .Name }}
	err = json.Unmarshal(b, &{{ renderCamel .Name }})
	if err != nil {
		{{- if $.HasValidity }}
		if errors.Is(err, ErrValidation) {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		{{- else }}
		// NOTE: lack of validity err check 
		{{- end }}
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	n, err := handler.store.Update({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }}, &{{ renderCamel .Name }})
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	fmt.Fprint(w, n)
}
{{- end }}
{{- block "deleteHandler" . }}
// Delete is the http handler func to allow removing a record
func (handler *{{ renderHandlerName . }}) Delete(w http.ResponseWriter, r *http.Request) {
	{{- template "primaryFromRequest" . }}
	n, err := handler.store.Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	fmt.Fprint(w, n)
}
{{- end }}
{{- block "attachMux" . }}
// Register will apply restful routes to the mux.
func (handler *{{ renderHandlerName . }}) Register(mux *http.ServeMux, prefix string) {
	mux.HandleFunc(prefix+"/{{ renderKebab .Name }}", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			handler.Post(w, r)
		case http.MethodGet:
			handler.GetMany(w, r)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})
	mux.HandleFunc(prefix+"/{{ renderKebab .Name }}/{{ renderPathValues . }}", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			handler.Get(w, r)
		case http.MethodPut:
			handler.Put(w, r)
		case http.MethodDelete:
			handler.Delete(w, r)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})
}
{{- end }}
{{- block "gatherPrimaryFn" . }}
// primaryFromRequest gathers the primary keys from the request for record identification
func (handler *{{ renderHandlerName . }}) primaryFromRequest(r *http.Request) ({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderGoKind $element }}{{ end }}, error) {
	{{- range $index, $element := .Primary }}
		{{- template "parseprimary" $element }}
	{{- end }}
	return {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel .Name }}{{ end }}, nil
}

// WhereClauseItemFromRequest creates a where clause for a sql statement
// based on fields in an entity, and if they where provided in the request.
func (handler *{{ renderHandlerName . }}) WhereClauseItemFromRequest(r *http.Request) []sqlsearch.WhereClauseItem {
	r.ParseForm()
	items := make([]sqlsearch.WhereClauseItem, 0, {{ len .Attributes }})
	{{- range $index, $element := .Attributes }}
		{{- template "collectattrfromreq" $element }}
	{{- end }}	
	return items
}
{{- end }}
{{- define "handler" }}
// {{ renderHandlerName . }} handles http routing for crud against a record
type {{ renderHandlerName . }} struct {
	store *{{ renderStoreName . }}
}

// New{{ renderHandlerName . }} provides a new handler
func New{{ renderHandlerName . }}(db *sql.DB) *{{ renderHandlerName . }} {
	return &{{ renderHandlerName . }}{store: New{{ renderStoreName . }}(db)}
}

{{- if ne .HasPrimary true }}

// NOTICE: {{ renderPascal .Name }} has no primary key, cannot generate CRUD handlers for {{ renderHandlerName . }}
{{- else }}
{{ template "gatherPrimaryFn" . }}
{{ template "attachMux" . }}
{{ template "createHandler" . }}
{{ template "readHandler" . }}
{{ template "readManyHandler" . }}
{{ template "updateHandler" . }}
{{ template "deleteHandler" . }}
{{- end }}
{{- end }}
