{{- block "createHandler" . }}
func (handler *{{ renderHandlerName . }}) Post(w http.ResponseWriter, r *http.Request) {
	b, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()

	var {{ renderCamel .Name }} {{ renderPascal .Name }}
	err = json.Unmarshal(b, &{{ renderCamel .Name }})
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	err = handler.store.Create(&{{ renderCamel .Name }})
	if err != nil {
		if errors.Is(err, ErrValidation) {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	b, err = json.Marshal({{ renderCamel .Name }})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Add("Content-Type", "application/json")
	w.Write(b)
}
{{- end }}
{{- block "readHandler" . }}
func (handler *{{ renderHandlerName . }}) Get({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{- end }}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		one, err := handler.store.Read({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		b, err := json.Marshal(one)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.Header().Add("Content-Type", "application/json")
		w.Write(b)
	}
}
{{- end }}
{{- block "readManyHandler" . }}
func (handler *{{ renderHandlerName . }}) GetMany(w http.ResponseWriter, r *http.Request) {
	limitStr := r.FormValue("limit")
	limit, err := strconv.Atoi(limitStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	offsetStr := r.FormValue("offset")
	offset, err := strconv.Atoi(offsetStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	many, err := handler.store.ReadMany(limit, offset)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	b, err := json.Marshal(many)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Add("Content-Type", "application/json")
	w.Write(b)
}
{{- end }}
{{- block "updateHandler" . }}
func (handler *{{ renderHandlerName . }}) Put({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{- end }}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		b, err := io.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		defer r.Body.Close()

		var {{ renderCamel .Name }} {{ renderPascal .Name }}
		err = json.Unmarshal(b, &{{ renderCamel .Name }})
		if err != nil {
			if errors.Is(err, ErrValidation) {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		n, err := handler.store.Update({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }}, &{{ renderCamel .Name }})
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		fmt.Fprint(w, n)
	}
}
{{- end }}
{{- block "deleteHandler" . }}
func (handler *{{ renderHandlerName . }}) Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{- end }}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		n, err := handler.store.Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		fmt.Fprint(w, n)
	}
}
{{- end }}
{{- block "attachMux" . }}
func (handler *{{ renderHandlerName . }}) Register(mux *http.ServeMux) {
	mux.HandleFunc("/{{ renderKebab .Name }}", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			handler.Post(w, r)
		case http.MethodGet:
			handler.GetMany(w, r)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})
	mux.HandleFunc("/{{ renderKebab .Name }}/{{ renderPathValues . }}", func(w http.ResponseWriter, r *http.Request) {
		{{- range $index, $element := .Primary }}
			{{- template "parseprimary" $element }}
		{{- end }}
		switch r.Method {
		case http.MethodGet:
			handler.Get({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})(w, r)
		case http.MethodPut:
			handler.Put({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})(w, r)
		case http.MethodDelete:
			handler.Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{- end }})(w, r)
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
	})
}
{{- end }}
{{- define "handler" }}
type {{ renderHandlerName . }} struct {
	store *{{ renderStoreName . }}
}
{{- if ne .HasPrimary true }}

// NOTICE: {{ renderPascal .Name }} has no primary key, cannot generate CRUD handlers for {{ renderHandlerName . }}
{{- else }}
{{ template "attachMux" . }}
{{ template "createHandler" . }}
{{ template "readHandler" . }}
{{ template "readManyHandler" . }}
{{ template "updateHandler" . }}
{{ template "deleteHandler" . }}
{{- end }}
{{- end }}
