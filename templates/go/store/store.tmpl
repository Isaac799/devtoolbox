{{- block "create" . }}
func (store *{{ renderStoreName . }}) Create({{ renderCamel .Name }} *{{ renderPascal .Name }}) error {
	q := `INSERT INTO {{ .Parent.Name }}.{{ .Name }} ({{ range $index, $element := .NonPrimary }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }}) VALUES ({{ range $index, $element := .NonPrimary }}{{ if ne $index 0 }}, {{ end }}${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}) RETURNING {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }}{{- end }}`
	row := store.db.QueryRow(q, {{ range $index, $element := .NonPrimary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }})
	if row.Err() != nil {
		return row.Err()
	}
	err := row.Scan({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}&{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }})
	if err != nil {
		return err
	}
	return nil
}
{{- end }}
{{- block "read" . }}
func (store *{{ renderStoreName . }}) Read({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (*{{ renderPascal .Name }}, error) {
	q := `SELECT {{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }} FROM {{ .Parent.Name }}.{{ .Name }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}`
	row := store.db.QueryRow(q, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if row.Err() != nil {
		return nil, row.Err()
	}
	var one {{ renderPascal .Name }}
	err := row.Scan({{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal .Name }}{{- end }})
	if err != nil {
		return nil, err
	}
	return &one, nil
}
{{- end }}
{{- block "readMany" . }}
func (store *{{ renderStoreName . }}) ReadMany(limit, offset int) ([]{{ renderPascal .Name }}, error) {
	q := `SELECT {{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }} FROM {{ .Parent.Name }}.{{ .Name }} ORDER BY {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }} DESC{{- end }} LIMIT $1 OFFSET $2`
	rows, err := store.db.Query(q, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	many := make([]{{ renderPascal .Name }}, 0, limit)
	for rows.Next() {
		var one {{ renderPascal .Name }}
		err := rows.Scan({{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal .Name }}{{- end }})
		if err != nil {
			return nil, err
		}
		many = append(many, one)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}
	return many, nil
}
{{- end }}
{{- block "update" . }}
func (store *{{ renderStoreName . }}) Update({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderPascal $element.Name }} {{ renderGoKind $element }}{{- end }}, {{ renderCamel .Name }} *{{ renderPascal .Name }}) (int64, error) {
	q := `UPDATE {{ .Parent.Name }}.{{ .Name }} SET {{ range $index, $element := .NonPrimary }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }}=${{ renderPlusOneOverAttrs $ $index }}{{ renderCast $element }}{{- end }}`
	result, err := store.db.Exec(q, {{ range $index, $element := .NonPrimary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }}, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderPascal $element.Name }}{{- end }})
	if err != nil {
		return 0, err
	}
	n, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return n, nil
}
{{- end }}
{{- block "delete" . }}
func (store *{{ renderStoreName . }}) Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (int64, error) {
	q := `DELETE FROM {{ .Parent.Name }}.{{ .Name }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}`
	result, err := store.db.Exec(q, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if err != nil {
		return 0, err
	}
	n, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return n, nil
}
{{- end }}
{{- define "store" }}
type {{ renderStoreName . }} struct {
    db *sql.DB
}
{{- if ne .HasPrimary true }}

// NOTICE: {{ renderPascal .Name }} has no primary key, cannot generate CRUD operations for {{ renderStoreName . }}
{{- else }}
{{ template "create" . }}
{{ template "read" . }}
{{ template "readMany" . }}
{{ template "update" . }}
{{ template "delete" . }}
{{- end }}
{{- end }}
