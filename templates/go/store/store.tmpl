{{- block "create" . }}
// Create will insert a record into the database. If invalid it will err before running
func (store *{{ renderStoreName . }}) Create({{ renderCamel .Name }} *{{ renderPascal .Name }}) error {
    {{- if $.HasValidity }}
	if err := {{ renderCamel .Name }}.Valid(); err != nil {
		return err
	}
	{{- else }}
	// NOTE: lack of validity check
	{{- end }}
	q := `INSERT INTO {{ .Parent.Name }}.{{ .Name }} ({{ range $index, $element := .AttributesToCreate }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }}) VALUES ({{ range $index, $element := .AttributesToCreate }}{{ if ne $index 0 }}, {{ end }}${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}) RETURNING {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }}{{- end }}`
	row := store.db.QueryRow(q, {{ range $index, $element := .AttributesToCreate }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }})
	if row.Err() != nil {
		return row.Err()
	}
	err := row.Scan({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}&{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }})
	if err != nil {
		return err
	}
	return nil
}
{{- end }}
{{- block "read" . }}
// Read will select a single record from then database given its primary key
func (store *{{ renderStoreName . }}) Read({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (*{{ renderPascal .Name }}, error) {
	q := `SELECT {{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }} FROM {{ .Parent.Name }}.{{ .Name }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }} AND {{ end }}{{ $element.Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}`
	row := store.db.QueryRow(q, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if row.Err() != nil {
		return nil, row.Err()
	}
	var one {{ renderPascal .Name }}
	err := row.Scan({{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal .Name }}{{- end }})
	if err != nil {
		return nil, err
	}
	return &one, nil
}
{{- end }}
{{- block "readRelations" . }}
{{ $entity := . }}
{{- range $index, $relation := $entity.Relations }}
{{- if $relation.Assoc }}
// ReadWith{{ renderPascal $relation.HasName }} selects a single '{{ $relation.Base.Name }}' including all '{{ $relation.HasName }}', via associative entity '{{ $relation.Assoc.Name }}'
func (store *{{ renderStoreName $entity }}) ReadWith{{ renderPascal $relation.HasName }}({{ range $index, $element := $entity.Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (*{{ renderPascal $relation.Name }}, error) {
	q := `
	SELECT 
		{{ range $index, $attr := $relation.Base.Attributes }}{{ if ne $index 0 }}, {{ end }}{{ $attr.Source.Parent.Name }}.{{ $attr.Name }} as {{ $attr.AsName }}{{- end }},
		{{ range $index, $attr := $relation.Has.Attributes }}{{ if ne $index 0 }}, {{ end }}{{ $attr.Source.Parent.Name }}.{{ $attr.Name }} as {{ $attr.AsName }}{{- end }}
	FROM {{ $entity.Parent.Name }}.{{ $entity.Name }} 
	{{- range $index, $join := $relation.KeysForAssocRelation }}
	LEFT JOIN {{ $relation.Assoc.Parent.Name }}.{{ $relation.Assoc.Name }} ON {{ range $index, $pk := $join }}{{ if ne $index 0 }} AND {{ end }}{{ $pk.Reference.Source.Parent.Name }}.{{ $pk.Name }} = {{ $pk.Reference.Final.Parent.Name }}.{{ $pk.Reference.Final.Name }}{{- end }} 
	{{- end }}
	WHERE {{ range $index, $pk := $entity.Primary }}{{ if ne $index 0 }} AND {{ end }}{{ $pk.Source.Parent.Name }}.{{ $pk.Name }}=${{ renderPlusOne $index }}{{ renderCast $pk }}{{- end }}`
	rows, err := store.db.Query(q, {{ range $index, $element := $entity.Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	one := {{ renderPascal $relation.Name }}{
		{{ renderPascal $relation.HasName }}: make([]{{ renderPascal $relation.Has.Name }}, 0, 10),
	}
	for rows.Next() {
		var {{ renderCamel $relation.Has.Name }} {{ renderPascal $relation.Has.Name }}
		err := rows.Scan(
			{{ range $index, $attr := $relation.Base.Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal $attr.Name }}{{- end }},
			{{ range $index, $attr := $relation.Has.Attributes }}{{ if ne $index 0 }}, {{ end }}&{{ renderCamel $relation.Has.Name }}.{{ renderPascal $attr.Name }}{{- end }},
		)
		one.{{ renderPascal $relation.HasName }} = append(one.{{ renderPascal $relation.HasName }}, {{ renderCamel $relation.Has.Name }})
		if err != nil {
			return nil, err
		}
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}
	return &one, nil
}
{{- else }}
// ReadWith{{ renderPascal $relation.HasName }} selects a single {{ $relation.Base.Name }} including its {{ $relation.Has.Name }}
func (store *{{ renderStoreName $entity }}) ReadWith{{ renderPascal $relation.HasName }}({{ range $index, $element := $entity.Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (*{{ renderPascal $relation.Name }}, error) {
	q := `
	SELECT 
		{{ range $index, $attr := $relation.Base.Attributes }}{{ if ne $index 0 }}, {{ end }}{{ $attr.Source.Parent.Name }}.{{ $attr.Name }} as {{ $attr.AsName }}{{- end }},
		{{ range $index, $attr := $relation.Has.Attributes }}{{ if ne $index 0 }}, {{ end }}{{ $attr.Source.Parent.Name }}.{{ $attr.Name }} as {{ $attr.AsName }}{{- end }}
	FROM {{ $entity.Parent.Name }}.{{ $entity.Name }} 
	LEFT JOIN {{ $relation.Has.Parent.Name }}.{{ $relation.Has.Name }} ON {{ range $index, $pk := $relation.KeysForDirectRelation }}{{ if ne $index 0 }} AND {{ end }}{{ $pk.Reference.Source.Parent.Name }}.{{ $pk.Name }} = {{ $pk.Reference.Final.Parent.Name }}.{{ $pk.Reference.Final.Name }}{{- end }} 
	WHERE {{ range $index, $pk := $entity.Primary }}{{ if ne $index 0 }} AND {{ end }}{{ $pk.Source.Parent.Name }}.{{ $pk.Name }}=${{ renderPlusOne $index }}{{ renderCast $pk }}{{- end }}`
	row := store.db.QueryRow(q, {{ range $index, $element := $entity.Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if row.Err() != nil {
		return nil, row.Err()
	}
	one := {{ renderPascal $relation.Name }}{
		{{ renderPascal $relation.HasName }}: {{ renderPascal $relation.Has.Name }}{},
	}
	err := row.Scan(
			{{ range $index, $attr := $relation.Base.Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal $attr.Name }}{{- end }},
			{{ range $index, $attr := $relation.Has.Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal $relation.HasName }}.{{ renderPascal $attr.Name }}{{- end }},
		)
	if err != nil {
		return nil, err
	}
	return &one, nil
}
{{- end }}
{{- end }}
{{- end }}
{{- block "readMany" . }}
// ReadMany will select a many record from then database given typical pagination constraints
func (store *{{ renderStoreName . }}) ReadMany(limit, offset int, whereClauseItems []sqlsearch.WhereClauseItem) ([]{{ renderPascal .Name }}, error) {
	placeholder, placeholderValues := sqlsearch.PlaceholderArgs(2, whereClauseItems)
	q := fmt.Sprintf(`SELECT {{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}{{- end }} FROM {{ .Parent.Name }}.{{ .Name }} %s ORDER BY {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ $element.Name }} DESC{{- end }} LIMIT $1 OFFSET $2`, placeholder)
	args := append([]any{limit, offset}, placeholderValues...)
	rows, err := store.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	many := make([]{{ renderPascal .Name }}, 0, limit)
	for rows.Next() {
		var one {{ renderPascal .Name }}
		err := rows.Scan({{ range $index, $element := .Attributes }}{{ if ne $index 0 }}, {{ end }}&one.{{ renderPascal .Name }}{{- end }})
		if err != nil {
			return nil, err
		}
		many = append(many, one)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}
	return many, nil
}
{{- end }}
{{- block "update" . }}
// Update will update all fields of a record in the database. If invalid it will err before running
func (store *{{ renderStoreName . }}) Update({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderPascal $element.Name }} {{ renderGoKind $element }}{{- end }}, {{ renderCamel .Name }} *{{ renderPascal .Name }}) (int64, error) {
    {{- if $.HasValidity }}
	if err := {{ renderCamel .Name }}.Valid(); err != nil {
		return 0, err
	}
	{{- else }}
	// NOTE: lack of validity check
	{{- end }}
	q := `UPDATE {{ .Parent.Name }}.{{ .Name }} SET {{ range $index, $element := .AttributesToUpdate }}{{ if ne $index 0 }}, {{ end }}{{ .Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }} AND {{ end }}{{ $element.Name }}=${{ renderPrimaryPlaceholder $ $index }}{{ renderCast $element }}{{- end }}`
	result, err := store.db.Exec(q, {{ range $index, $element := .AttributesToUpdate }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $.Name }}.{{ renderPascal $element.Name }}{{- end }}, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderPascal $element.Name }}{{- end }})
	if err != nil {
		return 0, err
	}
	n, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return n, nil
}
{{- end }}
{{- block "delete" . }}
// Delete will remove a record from the database given its primary key. Does not cascade.
func (store *{{ renderStoreName . }}) Delete({{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }} {{ renderGoKind $element }}{{ end }}) (int64, error) {
	q := `DELETE FROM {{ .Parent.Name }}.{{ .Name }} WHERE {{ range $index, $element := .Primary }}{{ if ne $index 0 }} AND {{ end }}{{ $element.Name }}=${{ renderPlusOne $index }}{{ renderCast $element }}{{- end }}`
	result, err := store.db.Exec(q, {{ range $index, $element := .Primary }}{{ if ne $index 0 }}, {{ end }}{{ renderCamel $element.Name }}{{ end }})
	if err != nil {
		return 0, err
	}
	n, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return n, nil
}
{{- end }}
{{- define "store" }}
// {{ renderStoreName . }} is a store to apply crud operations against sql
type {{ renderStoreName . }} struct {
    db *sql.DB
}

// New{{ renderStoreName . }} provides a new store. The db pointer should not be nil.
func New{{ renderStoreName . }}(db *sql.DB) *{{ renderStoreName . }} {
	return &{{ renderStoreName . }}{db: db}
}
{{- if ne .HasPrimary true }}

// NOTICE: {{ renderPascal .Name }} has no primary key, cannot generate CRUD operations for {{ renderStoreName . }}
{{- else }}
{{ template "create" . }}
{{ template "read" . }}
{{ template "readRelations" . }}
{{ template "readMany" . }}
{{ template "update" . }}
{{ template "delete" . }}
{{- end }}
{{- end }}
