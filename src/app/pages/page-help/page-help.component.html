<div class="p1">
    <h1>Help</h1>

    <em>What is it?</em>

    <p>
        A higher level approach to helping common CRUD needs.
    </p>

    <em>
        Is it ready to use?
    </em>

    <p>
        Not really. It mostly works, but is just a side project. I like the syntax I made, but its subject to change
        depending on peer feedback. Features are mostly tested, but all testing is manual and by eye/hand.
    </p>

    <em>
        Why not just use a LLM?
    </em>
    <p>
        This is not supposed to compete with or replace other tooling. This fills a void in my workflow, <em>for
            me</em>. My responsibilities are to develop new projects and maintain old ones. Often written by someone
        not around anymore. Documentation is great, but always falls short. What do I write? Who maintains the
        documents? Why maintain documentation if I am the only one who uses this and am already a week past due?
        If I am going to document something, <em>what</em> I write must have significance. That is where this tool comes
        in. (see bullet points below)
    </p>

    <em>Why use this tool?</em>

    <ul>
        <li>
            <strong>Practical.</strong> I am developing this tool for real needs that I have. Features are purposeful
            and powerful, not pomps.
        </li>
        <li><strong>Source controllable</strong>. The plain text markdown enables simple documentation of data
            structure. Especially helpful when working across multiple projects.
        </li>
        <li>
            <strong>Continuous Development</strong>. With the migration tool I am free to develop complex ideas and
            change them over time. This can also help find a path of least resistance when planning for the future, or
            quickly redefine previous solutions.
        </li>
        <!-- <li>
            <strong>ERD Generation</strong> is huge for me. I love ERDs but never liked that there was not a good way to
            make them on the computer. In school we hand-wrote them and sent pictures to the professor. When I got to
            the workforce I tried a few solutions like Visio and LibreOffice draw. Neither one really felt like the
            right tool. Using the GUI we can work in an ERD inspired flow.
        </li>

        <li>
            <strong>Printable</strong> the graphical interface is printable, giving a conceptual breakdown of the
            technicality. Useful for meetings with the boss or analysts.
        </li> -->
    </ul>

    <em>
        Why not use an ORM?
    </em>
    <p>
        This is not competing with an ORM - despite a lot of the generated code is CRUD orientated. Plus, as a general
        rule I have been trying to move away from libraries. When using a library I find myself limiting the features of
        an app to what a library gives me. More recently though, a core library for me became pay walled, leaving
        several applications I maintain without access to the documentation they where written with. This tool aims to
        encourage writing code and database migrations.
    </p>


    <em>What are the key concepts?</em>

    <p>
        I wanted a higher level approach, but keeping technical enough for my needs. To achieve this approach I landed
        on 2 things.
    </p>

    <ol>
        <li><strong>Folders</strong> are a way of categorizing ideas. Eventually turned into schemas.</li>
        <li><strong>Blueprints</strong> are a way of defining a specific thing. Eventually turned into tables and
            structs.</li>
    </ol>

    <em>Whats the difference in the GUI and the TUI?</em>

    <p>
        The Graphical User Interface (GUI) is pretty cool. It shows the relevant options and validation to fill out
        dynamically. However, it is not my focus, and as such is limited. For example, the unique is just a
        checkbox in the GUI, whereas in the TUI you can label unique constraints, creating groupings of unique fields.
        Plus a TUI approach is much more in line with what I need, more practical. Having plain text enables easier
        approach to adding new features, e.g. the migration page. Overall, the GUI one is more of a WIP, with the goal
        of a more fleshed out ERD-like solution down the road.
    </p>

    <h2>Syntax Guide</h2>

    <p>
        I apologize ahead of time, this is the first time I have tried to make my own syntax. To me it makes sense, and
        honestly that may be all that matters. I added a toggle option in the editor to allow switching between
        shorthand and more verbose modes.
    </p>

    <h3>
        Folders
    </h3>
    <p>
        Firstly, create a folder (schema)
    </p>
    <code>#  [ identifier ]</code>

    <h3>
        Blueprints
    </h3>
    <p>
        Secondly, create a blueprint (entity / table)
    </p>
    <code>##  [ identifier ]</code>

    <h3>
        Attributes
    </h3>
    <p>
        Finally, add attribute (properties / columns)
    </p>
    <code>-  [ identifier ] as [ type ] with [ options ]</code>

    <p>
        Shorthand to referencing other blueprints (identifier must already exist)
    </p>
    <code>-  &#64;[ identifier ] with [ options ]</code>

    <h3>Options</h3>
    <p>Note that all options can be truncated to just their first letter.</p>
    <ul>
        <li>
            <code>[ required ]</code> must have a value, cannot be null
        </li>
        <li>
            <code>[ unique ]:[ identifier ]</code> must be unique for matching identifier(s) (identifier is optional)
        </li>
        <li>
            <code>[ primary ]</code> this is a primary identifier.
        </li>
        <li>
            <code>[ default ]</code> this is the default value to set an attribute to. Tooltips will guide the expected
            format.
        </li>
        <li>
            <code>[ system ]</code> excludes it from certain things, like needing passed in on creation.
        </li>
    </ul>

    <h3>Types</h3>
    <p>All the following types are supported</p>
    <table [cellSpacing]="6">
        <thead>
            <tr>
                <th>Type</th>
                <th>Shorthand</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>date</code></td>
                <td></td>
                <td>a calendar date <code>YYYY-MM-DD</code></td>
            </tr>
            <tr>
                <td><code>time</code></td>
                <td></td>
                <td>a point in time <code>HH:MM:SS</code> with optional utc offset <code>-HH:MM</code></td>
            </tr>
            <tr>
                <td><code>timestamp</code></td>
                <td><code>ts</code></td>
                <td>includes date and time <code>YYYY-MM-DD HH:MM:SS</code> with optional utc offset <code>-HH:MM</code>
                </td>
            </tr>
            <tr>
                <td><code>string</code></td>
                <td><code>str</code></td>
                <td>a word or phrase</td>
            </tr>
            <tr>
                <td><code>bit</code></td>
                <td></td>
                <td>0 or 1</td>
            </tr>
            <tr>
                <td><code>character</code></td>
                <td><code>char</code></td>
                <td>a single character or letter</td>
            </tr>
            <tr>
                <td><code>decimal</code></td>
                <td><code>dec</code></td>
                <td>a decimal point number</td>
            </tr>
            <tr>
                <td><code>real</code></td>
                <td></td>
                <td>a real number</td>
            </tr>
            <tr>
                <td><code>float</code></td>
                <td></td>
                <td>a float number</td>
            </tr>
            <tr>
                <td><code>integer</code></td>
                <td><code>int</code></td>
                <td>a signed (+/-) integer</td>
            </tr>
            <tr>
                <td><code>boolean</code></td>
                <td><code>bool</code></td>
                <td>true or false</td>
            </tr>
            <tr>
                <td><code>money</code></td>
                <td></td>
                <td>a monetary value</td>
            </tr>
        </tbody>
    </table>

    <h3>Special Types</h3>
    <ul>
        <li>
            <code>[ auto increment | ++ ]</code> is a unique integer that increments. Automatically gains
            <code>[ primary & required & unique & system ] options.</code>
        </li>
        <li>
            <code>[ blueprint name ]</code> indicating another blueprint will reference it. Allowing for aliasing.
        </li>
    </ul>

    <h3>Macros</h3>
    <p>
        To help rapidly prototype ideas, use macros.
    </p>
    <p>
        Wrapping a new line in <code>!</code> runs a macro. The
        first one starts it, the second one runs it.
    </p>

    <table [cellSpacing]="6">
        <tbody>
            <tr>
                <th>What</th>
                <th>Macro</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            <tr>
                <td>
                    <strong>Associative Entities</strong>
                </td>
                <td>
                    <code>![ identifier ]:[ identifier ]!</code>
                </td>
                <td>
                    A common need is many-many relationships. Use this to relate 2 code-existing blueprints.

                </td>
                <td>
                    <code>!book:author!</code> will give us a blueprint that references a book and its author. Allowing
                    for a book to have multiple authors.
                </td>
            </tr>
            <tr>
                <td>
                    <strong>Lists</strong>
                </td>
                <td>
                    <code>!list:[ identifier ]!</code>
                </td>
                <td>
                    Another common need is a list of things to choose from, categorical data. For example, dropdown
                    lists in web
                    design. Use this to make a new blueprint with id and name attributes.
                </td>
                <td>
                    <code>!list:day of the week!</code> will give us a blueprint where we can store Monday
                    - Sunday.
                </td>
            </tr>
            <tr>
                <td>
                    <strong>Attributes</strong>
                </td>
                <td>
                    <code>!attr:[ keyword ]!</code>
                </td>
                <td>
                    <p>
                        Several attributes make re-appearances throughout different blueprints. These can help you from
                        having to write
                        the same thing over and over.
                    </p>
                    <ul>
                        <li><code>iat</code> inserted at timestamp </li>
                        <li><code>uat</code> updated at timestamp </li>
                        <li><code>word | string | str</code> unique string with upper limit </li>
                    </ul>

                </td>
                <td>
                    <code>!attr:iat!</code> will give us a attribute of the inserted at timestamp with a default value.
                </td>
            </tr>
        </tbody>
    </table>
</div>